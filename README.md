### domain层
`entity` 可变、来源于单一PO对象
`vo` 不可变、用于查询、一般是聚合对象

VO和Entity两者都是软件开发中常见的对象类型

简而言之就是Entity数据比较完整，VO是挑着来的

![img.png](docs/imgs/img.png)

**切量**和**降级开关**是常用于系统架构中的术语，尤其是在涉及动态配置和流量控制的场景中。它们通常用于应对高并发、资源限制、系统异常等情况，帮助系统在压力过大时避免崩溃并保证用户体验。下面详细解释这两个概念。

### **切量（Cut Range）**
**切量**是指在流量控制中，动态地切割或限制一部分流量或用户访问，以减少对系统的压力或者避免某些高风险操作的全面暴露。这个概念通常出现在高并发场景或者系统负载过重时。

#### 切量的应用场景：
- **用户分流**：根据用户的特征（如地区、设备类型等）或者在高峰期，对部分用户进行流量限制。例如，可以限制一部分用户访问某个服务，优先保障其他用户的体验。

- **流量隔离**：在某些场景下，如果某个用户群体或者某个特定操作导致系统负载过重，可以通过“切量”限制该群体的访问，保证其他用户的正常服务。

- **功能切换**：在多版本发布时，控制某些新功能的访问范围。例如，开发者可能会选择逐步开放新功能，先给一小部分用户开启，确认系统稳定后再全面推广。

#### 实际示例：
在一个电商平台的促销活动中，可以根据用户的 `userId` 或者其他属性来判断是否允许某个用户参与到限时活动中。假如某个用户群体的请求频率过高，系统可以通过切量技术，限制这一部分用户的请求量，避免系统崩溃或性能下降。

### **降级开关（Downgrade Switch）**
**降级开关**是指在系统发生异常或超负荷时，主动切换到一个相对简化或容错的模式，以保证系统能够继续运行而不是完全崩溃。降级通常用于业务系统中，尤其是在一些外部依赖（如数据库、第三方API等）不可用时，系统能够根据降级策略提供一定的服务。

#### 降级的应用场景：
- **外部服务不可用时**：假设一个系统依赖第三方支付接口，若该接口在某一时刻不可用，系统可以通过降级策略，转为使用备用的支付方式或者提供简单的提示信息，而不是让支付流程完全中断。

- **功能降级**：例如在一个大型电商平台，若数据库访问压力过大，系统可以通过降级方式，减少数据库查询的频率，或者将部分实时功能切换为缓存数据，从而避免数据库的压力导致系统崩溃。

- **流量高峰期**：在流量高峰期间（例如双十一等促销活动），系统可能会开启降级模式，关闭一些不必要的功能或限制请求次数，确保核心业务正常运行。

#### 实际示例：
假设一个电商平台提供了多种支付方式，包括支付宝、微信支付、银行卡支付等。如果在某个时刻，微信支付的服务无法访问，系统可以启用降级开关，自动切换到支付宝或银行卡支付，而不直接拒绝用户支付请求。这样，用户仍然可以顺利完成支付。

### **切量与降级开关的联系**
- **目的**：切量和降级开关的最终目的是相似的——确保系统在负载过重或出现问题时，仍然能够提供可用服务，不至于崩溃或出现长时间不可用的情况。两者都是为了增强系统的健壮性和容错能力。

- **区别**：
    - **切量**：更多是针对流量或者请求进行控制，限制特定用户、请求或者操作的数量。
    - **降级开关**：更多是通过改变系统的行为，主动降低某些服务的质量（如功能简化）或者将部分操作替换为更为轻量的方式，确保系统能在不完全崩溃的情况下继续工作。

### **如何实现切量与降级开关**
在实际的技术实现中，切量和降级开关通常是通过以下方式来实现的：

- **切量**：可以使用分布式限流、请求白名单/黑名单、流量控制等技术，如：
    - 基于用户的属性（ID、地区等）进行流量控制。
    - 使用熔断器（如 `Hystrix`）控制访问。
    - 通过 Redis、缓存等进行请求频率限制。

- **降级**：降级通常是通过配置开关或者判断某些外部系统的状态来控制的，常见实现方式有：
    - 使用 **配置中心**（如 Apollo、Nacos）动态控制降级开关。
    - 使用熔断器模式（如 `Hystrix`）来监控某个服务的健康状况，当外部服务不可用时自动触发降级策略。
    - 使用 **Fallback 方法**：在发生异常时，自动返回预定义的默认值或简单的错误信息，而不是完全崩溃。

### 总结
- **切量**：动态控制流量或请求的范围，减少某些用户的请求，减轻系统压力。
- **降级开关**：当系统负载过大或出现问题时，通过简化部分功能或操作，保障核心业务能持续运行。

这两者在分布式系统、高并发场景下非常常见，它们帮助系统在出现问题时能尽量保证一定的可用性和稳定性。



在 **领域驱动设计 (DDD)** 中，**仓储（Repository）** 是用于管理和持久化领域对象的组件。仓储的主要职责是提供一个抽象层，让领域模型可以方便地从数据存储（如数据库、缓存等）中获取或保存数据，而不需要直接依赖底层的存储实现。

### 仓储的主要职责：
1. **持久化领域对象**：仓储负责将领域对象（如 `Activity`, `Order`, `Product` 等）保存到数据库或其他存储介质中，或者从存储介质中检索它们。

2. **封装查询和更新逻辑**：仓储将对数据的操作（如查询、保存、删除）封装起来，使得业务逻辑层不需要关注底层存储的细节，只需要通过仓储接口来操作领域对象。

3. **领域对象的生命周期管理**：仓储在生命周期管理上起到一定的作用，通常它负责加载和保存整个领域对象的状态，而不只是简单的字段值。

4. **简化数据访问**：仓储层通过提供简单、直观的方法来访问领域对象，帮助业务逻辑层专注于业务处理而非数据库操作。例如，业务层调用 `repository.save(entity)` 或 `repository.findById(id)` 之类的接口，而无需关心 SQL 查询或数据库连接的细节。

### 什么样的 Bean 应该注入到仓储中？

#### 1. **与数据持久化相关的 Bean**
仓储的核心职责是与存储介质（如数据库、缓存、文件系统等）交互。因此，应该将与数据存储和访问有关的组件注入到仓储中。常见的注入类型有：
- **DAO（Data Access Object）**：负责与数据库直接交互，进行增删改查操作。仓储通常会依赖于 DAO 或类似的组件来执行具体的数据库操作。
- **ORM 框架（如 Hibernate, JPA）**：如果使用 ORM 框架来进行数据持久化，那么仓储中会注入相关的 `EntityManager` 或 `Session` 等对象，用于操作数据库中的实体。
- **缓存客户端**：如果系统使用缓存技术（如 Redis、Memcached 等），仓储也可能会依赖缓存客户端（如 `RedissonClient`）来存取缓存数据。

#### 2. **领域对象**
仓储直接处理领域对象，它负责将领域对象从数据库加载并持久化。领域对象通常是业务模型的一部分，是代表业务概念的对象，封装了业务逻辑。仓储通过 `save()`、`findById()` 等方法对领域对象进行操作。

例如，`ActivityRepository` 可能会注入 `IGroupBuyActivityDao`，用来保存和查询 `GroupBuyActivity` 领域对象；`OrderRepository` 可能会注入 `IOrderDao`，用于保存和查询订单对象。

#### 3. **与仓储操作相关的服务类**
除了 DAO 和领域对象，有时仓储也可能依赖于一些服务类，用于辅助执行一些仓储相关的逻辑。例如，仓储可以依赖于：
- **事务管理服务**：管理数据库事务，确保多个数据库操作的原子性。
- **日志服务**：记录仓储操作的日志，帮助调试和追踪问题。
- **外部配置服务**：如 `DCCService`，为仓储提供一些动态配置。

#### 4. **工具类或帮助类**
仓储可能会依赖一些工具类，用于辅助执行常见任务，例如：转换、校验、格式化等。
- **数据转换工具**：将数据库模型（DTO）与领域模型（DO）之间进行转换的工具类。
- **验证工具**：用于校验领域对象的有效性，确保它们符合业务规则。

#### 5. **跨领域服务**（可选）
有时，仓储层可能需要依赖跨领域的服务。例如：
- **缓存服务**：如果在仓储操作时涉及缓存的更新或查询，可以将缓存服务（如 `IRedisService`）注入到仓储中。
- **异步操作服务**：如果仓储需要异步执行某些操作，可以将异步执行相关的服务注入仓储。

### 不应该注入到仓储中的 Bean
仓储的职责是处理数据存取，而不是执行具体的业务逻辑。因此，**不应该将业务逻辑**、**控制器层**的组件或者 **外部服务（非与数据存储相关的服务）** 注入到仓储中。

例如：
- **业务服务（Service）**：仓储不应该直接依赖于业务服务，因为业务服务负责应用层的逻辑，而仓储专注于数据存取。
- **控制器**：仓储层不应该直接依赖于控制器，因为控制器负责处理 HTTP 请求，而仓储只需要关注数据存储。
- **领域服务（Domain Services）**：如果业务逻辑涉及复杂的领域服务，应该在业务层进行处理，仓储层不应该负责处理复杂的业务逻辑。

### 例子：
假设你有一个名为 `ActivityRepository` 的仓储类，它负责持久化 `GroupBuyActivity` 对象。它的依赖可能会如下：

```java
@Repository
public class ActivityRepository {
    
    @Resource
    private IGroupBuyActivityDao groupBuyActivityDao;  // 数据库DAO
    @Resource
    private IRedisService redisService;  // 缓存服务
    @Resource
    private DCCService dccService;  // 动态配置服务
    
    public GroupBuyActivity findById(Long id) {
        // 先查询缓存
        String cacheKey = "group_buy_activity:" + id;
        GroupBuyActivity activity = redisService.get(cacheKey);
        
        if (activity == null) {
            // 缓存中没有，再从数据库查询
            activity = groupBuyActivityDao.findById(id);
            // 数据库查询后，将结果放入缓存
            redisService.set(cacheKey, activity);
        }
        
        return activity;
    }
    
    public void save(GroupBuyActivity activity) {
        // 保存到数据库
        groupBuyActivityDao.save(activity);
        // 保存到缓存
        String cacheKey = "group_buy_activity:" + activity.getId();
        redisService.set(cacheKey, activity);
    }
}
```

在这个例子中，`ActivityRepository` 注入了与数据存储和缓存相关的服务（`IGroupBuyActivityDao`, `IRedisService`），以及一个配置服务（`DCCService`），这些都是仓储所需要的组件。这样，仓储只关注如何获取和存储数据，而业务层和控制器层则可以专注于业务逻辑和请求处理。

### 总结：
- **仓储的职责**：持久化和检索领域对象，封装与数据存储相关的操作。
- **仓储中应该注入的 Bean**：与数据存取、持久化、缓存、事务管理等相关的组件。
- **不应该注入的 Bean**：控制器、业务服务、领域服务等负责业务逻辑的组件。